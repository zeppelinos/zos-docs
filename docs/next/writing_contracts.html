<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Writing upgradeable contracts · ZeppelinOS</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Writing upgradeable contracts · ZeppelinOS"/><meta property="og:type" content="website"/><meta property="og:url" content="https://docs.zeppelinos.org/index.html"/><meta property="og:description" content="When working with upgradeable contracts in ZeppelinOS, there are a few minor caveats to keep in mind when writing your Solidity code. It&#x27;s worth mentioning that these restrictions have their roots in how the Ethereum VM works, and apply to all projects that work with upgradeable contracts, not just ZeppelinOS."/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-102575245-1', 'auto');
              ga('send', 'pageview');
            </script><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:100,200,300,400,500,700,400italic,700italic"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible doc"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/logo.svg" alt="ZeppelinOS"/></a><a href="/versions.html"><h3>next</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/next/start.html" target="_self">Quickstart</a></li><li class=""><a href="/docs/next/apis.html" target="_self">Reference</a></li><li class=""><a href="https://blog.zeppelinos.org" target="_self">Blog</a></li><li class=""><a href="https://forum.zeppelin.solutions" target="_self">Forum</a></li><li class=""><a href="https://github.com/zeppelinos" target="_self">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>GUIDES</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>OVERVIEW</h3><ul><li class="navListItem"><a class="navItem" href="/docs/next/start.html">ZeppelinOS</a></li><li class="navListItem"><a class="navItem" href="/docs/next/new_2.html">What&#x27;s new in ZeppelinOS 2.0</a></li><li class="navListItem"><a class="navItem" href="/docs/next/new_2.2.html">What&#x27;s new in ZeppelinOS 2.2</a></li></ul></div><div class="navGroup navGroupActive"><h3>QUICKSTART</h3><ul><li class="navListItem"><a class="navItem" href="/docs/next/zepkit.html">ZepKit</a></li><li class="navListItem"><a class="navItem" href="/docs/next/deploying.html">Deploying your first project</a></li><li class="navListItem"><a class="navItem" href="/docs/next/upgrading.html">Upgrading your project</a></li><li class="navListItem"><a class="navItem" href="/docs/next/linking.html">Linking to EVM packages</a></li><li class="navListItem"><a class="navItem" href="/docs/next/publishing.html">Publishing an EVM package</a></li><li class="navListItem"><a class="navItem" href="/docs/next/vouching.html">Vouching for EVM packages</a></li></ul></div><div class="navGroup navGroupActive"><h3>GUIDES</h3><ul><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/docs/next/writing_contracts.html">Writing upgradeable contracts</a></li><li class="navListItem"><a class="navItem" href="/docs/next/testing.html">Testing upgradeable projects</a></li><li class="navListItem"><a class="navItem" href="/docs/next/erc20_onboarding.html">Onboarding ERC20 tokens</a></li><li class="navListItem"><a class="navItem" href="/docs/next/upgrades_governance.html">Upgrades governance</a></li><li class="navListItem"><a class="navItem" href="/docs/next/zos_lib.html">Using the ZeppelinOS programmatic library</a></li></ul></div><div class="navGroup navGroupActive"><h3>ADVANCED TOPICS</h3><ul><li class="navListItem"><a class="navItem" href="/docs/next/faq.html">Frequently asked questions</a></li><li class="navListItem"><a class="navItem" href="/docs/next/configuration.html">Configuration Files</a></li><li class="navListItem"><a class="navItem" href="/docs/next/architecture.html">Contracts Architecture</a></li><li class="navListItem"><a class="navItem" href="/docs/next/pattern.html">ZeppelinOS Upgrades Pattern</a></li><li class="navListItem"><a class="navItem" href="/docs/next/token_mechanics.html">ZEP Token Mechanics</a></li><li class="navListItem"><a class="navItem" href="/docs/next/whitepaper.html">Whitepaper</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Writing upgradeable contracts</h1></header><article><div><span><p>When working with upgradeable contracts in ZeppelinOS, there are a few minor caveats to keep in mind when writing your Solidity code. It's worth mentioning that these restrictions have their roots in how the Ethereum VM works, and apply to all projects that work with upgradeable contracts, not just ZeppelinOS.</p>
<h2><a class="anchor" aria-hidden="true" id="initializers"></a><a href="#initializers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Initializers</h2>
<p>You can use your Solidity contracts in ZeppelinOS without any modifications, except for their <em>constructors</em>. Due to a requirement of the proxy-based upgradeability system, no constructors can be used in upgradeable contracts. You can read in-depth about the reasons behind this restriction <a href="/docs/next/pattern.html#the-constructor-caveat">in the ZeppelinOS Upgrades Pattern page</a>.</p>
<p>This means that, when using a contract within ZeppelinOS, you need to change its constructor into a regular function, typically named <code>initialize</code>, where you run all the setup logic:</p>
<pre><code class="hljs css solidity">// NOTE: <span class="hljs-keyword">Do</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">use</span> this code snippet, it<span class="hljs-symbol">'s</span> incomplete <span class="hljs-keyword">and</span> has a critical vulnerability!

contract MyContract {
  uint256 public x;

  <span class="hljs-keyword">function</span> <span class="hljs-title">initialize</span>(uint256 _x) public {
    x = _x;
  }
}
</code></pre>
<p>However, while Solidity ensures that a <code>constructor</code> is called only once in the lifetime of a contract, a regular function can be called many times. To prevent a contract from being <em>initialized</em> multiple times, you need to add a check to ensure the <code>initialize</code> function is called only once:</p>
<pre><code class="hljs css solidity">contract MyContract {
  uint256 <span class="hljs-keyword">public</span> x;
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">private</span> initialized;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initialize</span><span class="hljs-params">(uint256 _x)</span> <span class="hljs-title">public</span> </span>{
    <span class="hljs-keyword">require</span>(!initialized);
    initialized = <span class="hljs-keyword">true</span>;
    x = _x;
  }
}
</code></pre>
<p>Since this pattern is very common when writing upgradeable contracts, ZeppelinOS provides an <code>Initializable</code> base contract that has an <code>initializer</code> modifier that takes care of this:</p>
<pre><code class="hljs css solidity"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> "zos-lib/contracts/Initializable.sol";</span>

contract MyContract <span class="hljs-keyword">is</span> Initializable {
  uint256 <span class="hljs-keyword">public</span> x;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initialize</span><span class="hljs-params">(uint256 _x)</span> <span class="hljs-title">initializer</span> <span class="hljs-title">public</span> </span>{
    x = _x;
  }
}
</code></pre>
<p>Another difference between a <code>constructor</code> and a regular function is that Solidity takes care of automatically invoking the constructors of all ancestors of a contract. When writing an initializer, you need to take special care to manually call the initializers of all parent contracts:</p>
<pre><code class="hljs css solidity"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> "zos-lib/contracts/Initializable.sol";</span>

contract BaseContract <span class="hljs-keyword">is</span> Initializable {
  uint256 <span class="hljs-keyword">public</span> y;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span> <span class="hljs-title">initializer</span> <span class="hljs-title">public</span> </span>{
    y = <span class="hljs-number">42</span>;
  }
}

contract MyContract <span class="hljs-keyword">is</span> BaseContract {
  uint256 <span class="hljs-keyword">public</span> x;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initialize</span><span class="hljs-params">(uint256 _x)</span> <span class="hljs-title">initializer</span> <span class="hljs-title">public</span> </span>{
    BaseContract.initialize(); <span class="hljs-comment">// Do not forget this call!</span>
    x = _x;
  }
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="use-upgradeable-packages"></a><a href="#use-upgradeable-packages" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Use upgradeable packages</h3>
<p>Keep in mind that this restriction affects not only your contracts, but also the contracts you import from a library. For instance, if you use the <a href="https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v2.0.0/contracts/token/ERC20/ERC20Detailed.sol"><code>ERC20Detailed</code> token implementation</a> from OpenZeppelin, the contract initializes the token's name, symbol and decimals in its constructor:</p>
<pre><code class="hljs css solidity">Contract ERC20Detailed is IERC20 {
  string <span class="hljs-built_in">private</span> <span class="hljs-variable">_name</span>;
  string <span class="hljs-built_in">private</span> <span class="hljs-variable">_symbol</span>;
  uint8 <span class="hljs-built_in">private</span> <span class="hljs-variable">_decimals</span>;

  constructor(string <span class="hljs-built_in">name</span>, string symbol, uint8 decimals) public {
    <span class="hljs-variable">_name</span> = <span class="hljs-built_in">name</span>;
    <span class="hljs-variable">_symbol</span> = symbol;
    <span class="hljs-variable">_decimals</span> = decimals;
  }
}
</code></pre>
<p>This means that you should not be using these contracts in your ZeppelinOS project. Instead, make sure to use <code>openzeppelin-eth</code>, which is an official fork of OpenZeppelin, which has been modified to use initializers instead of constructors. For instance, an ERC20 implementation provided by <code>openzeppelin-eth</code> is the <a href="https://github.com/OpenZeppelin/openzeppelin-eth/blob/v2.0.2/contracts/token/ERC20/ERC20Mintable.sol"><code>ERC20Mintable</code></a>:</p>
<pre><code class="hljs css solidity">contract ERC20Mintable <span class="hljs-keyword">is</span> Initializable, ERC20, MinterRole {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initialize</span><span class="hljs-params">(address sender)</span> <span class="hljs-title">public</span> <span class="hljs-title">initializer</span> </span>{
    MinterRole.initialize(sender);
  }
  [...]
}
</code></pre>
<p>Whether it is OpenZeppelin or another EVM package, always make sure that the package is set up to handle upgradeable contracts.</p>
<h3><a class="anchor" aria-hidden="true" id="avoid-initial-values-in-field-declarations"></a><a href="#avoid-initial-values-in-field-declarations" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Avoid initial values in field declarations</h3>
<p>Solidity allows defining initial values for fields when declaring them in a contract.</p>
<pre><code class="hljs css solidity"><span class="hljs-attribute">contract</span> MyContract {
  <span class="hljs-attribute">uint256</span> public hasInitialValue = <span class="hljs-number">42</span>;
}
</code></pre>
<p>This is equivalent to setting these values in the constructor, and as such, will not work for upgradeable contracts. Make sure that all initial values are set in an initializer function as shown above; otherwise, any upgradeable instances will not have these fields set.</p>
<pre><code class="hljs css solidity">contract MyContract <span class="hljs-keyword">is</span> Initializable {
  uint256 <span class="hljs-keyword">public</span> hasInitialValue;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span> <span class="hljs-title">initializer</span> <span class="hljs-title">public</span> </span>{
    hasInitialValue = <span class="hljs-number">42</span>;
  }
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="creating-new-instances-from-your-contract-code"></a><a href="#creating-new-instances-from-your-contract-code" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creating new instances from your contract code</h2>
<p>When creating a new instance of a contract from your contract's code, these creations are handled directly by Solidity and not by ZeppelinOS, which means that <strong>these contracts will not be upgradeable</strong>.</p>
<p>For instance, in the following example, even if <code>MyContract</code> is upgradeable (if created via <code>zos create MyContract</code>), the <code>token</code> contract created is not:</p>
<pre><code class="hljs css solidity"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> "zos-lib/contracts/Initializable.sol";</span>
<span class="hljs-meta"><span class="hljs-meta-keyword">import</span> "openzeppelin-eth/contracts/token/ERC20/ERC20.sol";</span>
<span class="hljs-meta"><span class="hljs-meta-keyword">import</span> "openzeppelin-eth/contracts/token/ERC20/RC20Detailed.sol";</span>

contract MyContract <span class="hljs-keyword">is</span> Initializable {
  ERC20 <span class="hljs-keyword">public</span> token;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span> <span class="hljs-title">initializer</span> <span class="hljs-title">public</span> </span>{
    token = <span class="hljs-keyword">new</span> ERC20Detailed(<span class="hljs-string">"Test"</span>, <span class="hljs-string">"TST"</span>, <span class="hljs-number">18</span>); <span class="hljs-comment">// This contract will not be upgradeable</span>
  }
}
</code></pre>
<p>The easiest way around this issue is to avoid creating contracts on your own altogether: instead of creating a contract in an <code>initialize</code> function, simply accept an instance of that contract as a parameter, and inject it after creating it from ZeppelinOS:</p>
<pre><code class="hljs css solidity"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> "zos-lib/contracts/Initializable.sol";</span>
<span class="hljs-meta"><span class="hljs-meta-keyword">import</span> "openzeppelin-eth/contracts/token/ERC20/ERC20.sol";</span>

contract MyContract <span class="hljs-keyword">is</span> Initializable {
  ERC20 <span class="hljs-keyword">public</span> token;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initialize</span><span class="hljs-params">(ERC20 _token)</span> <span class="hljs-title">initializer</span> <span class="hljs-title">public</span> </span>{
    token = _token; <span class="hljs-comment">// This contract will be upgradeable if it was created via ZeppelinOS</span>
  }
}
</code></pre>
<pre><code class="hljs css console"><span class="hljs-meta">$</span><span class="bash"> TOKEN=$(zos create TokenContract)</span>
<span class="hljs-meta">$</span><span class="bash"> zos create MyContract --init --args <span class="hljs-variable">$TOKEN</span></span>
</code></pre>
<p>An advanced alternative, if you need to create upgradeable contracts on the fly, is to keep an instance of your ZeppelinOS <code>App</code> in your contracts. The <a href="/docs/next/application_App.html"><code>App</code></a> is a contract that acts as the entrypoint for your ZeppelinOS project, which has references to your logic implementations, and can create new contract instances:</p>
<pre><code class="hljs css solidity"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> "zos-lib/contracts/Initializable.sol";</span>
<span class="hljs-meta"><span class="hljs-meta-keyword">import</span> "zos-lib/contracts/application/App.sol";</span>

contract MyContract <span class="hljs-keyword">is</span> Initializable {
  App <span class="hljs-keyword">private</span> app;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initialize</span><span class="hljs-params">(App _app)</span> <span class="hljs-title">initializer</span> <span class="hljs-title">public</span> </span>{
    app = _app;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createNewToken</span><span class="hljs-params">()</span> <span class="hljs-title">public</span> <span class="hljs-title">returns</span><span class="hljs-params">(address)</span> </span>{
    <span class="hljs-keyword">return</span> app.create(<span class="hljs-string">"openzeppelin-eth"</span>, <span class="hljs-string">"StandaloneERC20"</span>);
  }
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="potentially-unsafe-operations"></a><a href="#potentially-unsafe-operations" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Potentially unsafe operations</h2>
<p>When working with upgradeable smart contracts, you will always interact with the contract instance, and never with the underlying logic contract. However, nothing prevents a malicious actor from sending transactions to the logic contract directly. This does not pose a threat, since any changes to the state of the logic contracts do not affect your contract instances, as the storage of the logic contracts is never used in your project.</p>
<p>There is, however, an exception. If the direct call to the logic contract triggers a <code>selfdestruct</code> operation, then the logic contract will be destroyed, and all your contract instances will end up delegating all calls to an address without any code. This would effectively break all contract instances in your project.</p>
<p>A similar effect can be achieved if the logic contract contains a <code>delegatecall</code> operation. If the contract can be made to <code>delegatecall</code> into a malicious contract that contains a <code>selfdestruct</code>, then the calling contract will be destroyed.</p>
<p>As such, it is strongly recommended to avoid any usage of either <code>selfdestruct</code> or <code>delegatecall</code> in your contracts. If you need to include them, make absolutely sure they cannot be called by an attacker on an uninitialized logic contract.</p>
<h2><a class="anchor" aria-hidden="true" id="modifying-your-contracts"></a><a href="#modifying-your-contracts" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Modifying your contracts</h2>
<p>When writing new versions of your contracts, either due to new features or bugfixing, there is an additional restriction to observe: you cannot change the order in which the contract state variables are declared, nor their type. You can read more about the reasons behind this restriction <a href="/docs/next/pattern.html">in the pattern section</a>.</p>
<p>This means that if you have an initial contract that looks like this:</p>
<pre><code class="hljs css solidity">contract MyContract {
  uint256 <span class="hljs-keyword">private</span> x;
  <span class="hljs-built_in">string</span> <span class="hljs-keyword">private</span> y;
}
</code></pre>
<p>Then you cannot change the type of a variable:</p>
<pre><code class="hljs css solidity">contract MyContract {
  <span class="hljs-built_in">string</span> <span class="hljs-keyword">private</span> x;
  <span class="hljs-built_in">string</span> <span class="hljs-keyword">private</span> y;
}
</code></pre>
<p>Or change the order in which they are declared:</p>
<pre><code class="hljs css solidity">contract MyContract {
  <span class="hljs-built_in">string</span> <span class="hljs-keyword">private</span> y;
  uint256 <span class="hljs-keyword">private</span> x;
}
</code></pre>
<p>Or introduce a new variable before existing ones:</p>
<pre><code class="hljs css solidity">contract MyContract {
  <span class="hljs-built_in">bytes</span> <span class="hljs-keyword">private</span> a;
  uint256 <span class="hljs-keyword">private</span> x;
  <span class="hljs-built_in">string</span> <span class="hljs-keyword">private</span> y;
}
</code></pre>
<p>Or remove an existing variable:</p>
<pre><code class="hljs css solidity">contract MyContract {
  <span class="hljs-built_in">string</span> <span class="hljs-keyword">private</span> y;
}
</code></pre>
<p>If you need to introduce a new variable, make sure you always do so at the end:</p>
<pre><code class="hljs css solidity">contract MyContract {
  uint256 <span class="hljs-keyword">private</span> x;
  <span class="hljs-built_in">string</span> <span class="hljs-keyword">private</span> y;
  <span class="hljs-built_in">bytes</span> <span class="hljs-keyword">private</span> z;
}
</code></pre>
<p>Keep in mind that if you rename a variable, then it will keep the same value as before after upgrading. This may be the desired behaviour if the new variable is semantically the same as the old one:</p>
<pre><code class="hljs css solidity">contract MyContract {
  uint256 <span class="hljs-keyword">private</span> x;
  <span class="hljs-built_in">string</span> <span class="hljs-keyword">private</span> z; <span class="hljs-comment">// starts with the value from `y`</span>
}
</code></pre>
<p>And if you remove a variable from the end of the contract, note that the storage will not be cleared. A subsequent update that adds a new variable will cause that variable to read the leftover value from the deleted one.</p>
<pre><code class="hljs css solidity">contract MyContract {
  uint256 <span class="hljs-keyword">private</span> x;
}

<span class="hljs-comment">// Then upgraded to...</span>

contract MyContract {
  uint256 <span class="hljs-keyword">private</span> x;
  <span class="hljs-built_in">string</span> <span class="hljs-keyword">private</span> z; <span class="hljs-comment">// starts with the value from `y`</span>
}
</code></pre>
<p>Note that you may also be inadvertently changing the storage variables of your contract by changing its parent contracts. For instance, if you have the following contracts:</p>
<pre><code class="hljs css solidity">contract <span class="hljs-keyword">A</span> {
  uint256 a;
}

<span class="hljs-keyword">contract</span> <span class="hljs-keyword">B</span> {
  uint256 b;
}

<span class="hljs-keyword">contract</span> <span class="hljs-keyword">MyContract</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">A</span>, <span class="hljs-keyword">B</span> { }
</code></pre>
<p>Then modifying <code>MyContract</code> by swapping the order in which the base contracts are declared, or introducing new base contracts, will change how the variables are actually stored:</p>
<pre><code class="hljs css solidity"><span class="hljs-built_in">contract</span> MyContract <span class="hljs-built_in">is</span> B, A { }
</code></pre>
<p>You also cannot add new variables to base contracts, if the child has any variables of its own. Given the following scenario:</p>
<pre><code class="hljs css solidity">contract <span class="hljs-keyword">Base</span> {
  uint256 base1;
}

<span class="hljs-keyword">contract</span> <span class="hljs-keyword">Child</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">Base</span> {
  uint256 child;
}
</code></pre>
<p>If <code>Base</code> is modified to add an extra variable:</p>
<pre><code class="hljs css solidity"><span class="hljs-symbol">contract</span> <span class="hljs-keyword">Base </span>{
  uint256 <span class="hljs-keyword">base1;
</span>  uint256 <span class="hljs-keyword">base2;
</span>}
</code></pre>
<p>Then the variable <code>base2</code> would be assigned the slot that <code>child</code> had in the previous version. A workaround for this is to declare unused variables on base contracts that you may want to extend in the future, as a means of &quot;reserving&quot; those slots. Note that this trick does not involve increased gas usage.</p>
<blockquote>
<p>Violating any of these storage layout restrictions will cause the upgraded version of the contract to have its storage values mixed up, and can lead to critical errors in your application.</p>
</blockquote>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="vouching.html">← Vouching for EVM packages</a><a class="docs-next button" href="testing.html">Testing upgradeable projects →</a></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/symbol-zeppelin.png" alt="ZeppelinOS" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/start.html">Guides</a><a href="/docs/apis.html">Reference</a></div><div><h5>Community</h5><a href="https://forum.zeppelin.solutions/" target="_blank">Forum</a><a href="https://t.me/zeppelinos/" target="_blank">Telegram chat</a></div><div><h5>More</h5><a href="https://zeppelinos.org">Main Site</a><a href="https://blog.zeppelinos.org">Blog</a><a href="https://github.com/zeppelinos">GitHub</a></div></section><a href="https://zeppelinos.org" target="_blank" class="fbOpenSource"><img src="/img/logo.svg" alt="ZeppelinOS" width="170" height="45"/></a><section class="copyright">Copyright © 2017-present ZeppelinOS Global</section><section class="report-bugs"><a href="https://github.com/zeppelinos/zos/issues/new?labels=kind:documentation">Report a bug on this site</a></section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                
                apiKey: '8d0b5afbba49947d9efb5659d1b08df7',
                indexName: 'zeppelinos',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>